#include <iostream>
#include <vector>
#include "divider.hh"
#include <common/_.hh>

divider::Divider __GLOBAL_DIVIDER__;

extern "C" bool init (const common::utils::config::dict * cfg, common::plugin::Factory * factory) {
    return __GLOBAL_DIVIDER__.configure (*cfg, *factory);	
}

extern "C" void compute () {
    __GLOBAL_DIVIDER__.compute ();
}

extern "C" void dispose () {
    __GLOBAL_DIVIDER__.dispose ();
}

extern "C" std::string help () {
    std::stringstream ss;
    ss << "divider (" << __PLUGIN_VERSION__ << ")" << std::endl;
    ss << __COPYRIGHT__ << std::endl << std::endl;
    
    ss << "Divider is a core plugin, it divides the consumption of the different components of a machine between the cgroups, using perf events has a key divider." << std::endl;
    ss << "It supports the division of energy consumption from a CPU, the RAM, and as many GPUs as there can be on the machine." << std::endl << std::endl;
    
    ss << "The following presents an example of a configuration, for the sensor that has to be placed in '/etc/anon/config.toml'." << std::endl << std::endl;
    ss << "=== config.toml : " << std::endl;
    ss << "[sensor]" << std::endl;
    ss << "freq = 1 # frequency of update in hertz (the higher the faster)" << std::endl;
    ss << "log-lvl = \"info\" # debug < success < info < warn < error < none" << std::endl;
    ss << "log-path = \"/etc/anon/log\" # log file (empty means stdout)" << std::endl;
    ss << "core = \"divider\" # the name of the core plugin to use for the sensor" << std::endl << std::endl;
    ss << "# the directory in which result will be written" << std::endl;
    ss << "output-dir = \"/etc/anon/results\""<< std::endl << std::endl;

    ss << "# Compute the division between cgroups based on perf counter from all machine" << std::endl;
    ss << "#                                   or based on the sum of the perf counters of the watched cgroups" << std::endl;
    ss << "perf-division-base = \"machine\" # \"sum\""  << std::endl << std::endl;

    ss << "# delete cgroup result directories when the cgroup no longer exists" << std::endl;
    ss << "delete-res = true" << std::endl << std::endl;

    ss << "# if true mount the result directory in tmpfs (less i/o generated by anon)" << std::endl;
    ss << "mount-tmpfs = true" << std::endl;
    
    ss << std::endl;
    ss << "# following configuration is optional" << std::endl;
    ss << "# It activates some part of the divider" << std::endl;
    ss << std::endl;
    ss << "[cpu] # configuration to enable CPU energy reading" << std::endl;
    ss << "name = \"rapl\" # rapl plugin for compatible intel or amd cpus" << std::endl;
    ss << std::endl;
    ss << "[ram] # configuration to enable RAM energy reading" << std::endl;
    ss << "name = \"rapl\" # rapl plugin for compatible intel or amd cpus" << std::endl;
    ss << std::endl;
    ss << "[gpu:0] # configuration to enable GPU energy reading" << std::endl;
    ss << "name = \"nvidia\" # nvidia plugin for nvidia GPUs" << std::endl;
    ss << std::endl;
    ss << "# A machine can have different GPU from different constructors" << std::endl;
    ss << "# For example a integrated GPU, and an nvidia GPU card" << std::endl;
    ss << "[gpu:1] # configuration to enable GPU energy " << std::endl;
    ss << "name = \"rapl\" # rapl plugin form compatible intel of amd cpus" << std::endl;
    ss << "===" << std::endl << std::endl;

    ss << "The divider core plugin uses another configuration file, in '/etc/anon/cgroups', to filter the cgroups that are watched by the sensor, and ignore unwanted cgroups." << std::endl;
    ss << "This configuration file is a list of rules, every rules must start with a slice (a cgroup that contains other cgroups)." << std::endl;
    ss << "For example 'my.slice/*'., will make the sensor watch all the cgroups in the slice 'my.slice', and 'system.slice/docker*' will watch all the cgroups in 'system.slice' that starts with 'docker'." << std::endl;
    ss << "Basically, it list all the cgroups that would be found if the command 'ls my_rule' was run in the cgroup mount directory." << std::endl;
    ss << "The following presents an example of configuration for cgroup listing that has to be placed in '/etc/anon/cgroups'" << std::endl << std::endl; 
    ss << "=== cgroups : " << std::endl;
    ss << "anon.slice/*" << std::endl;
    ss << "system.slice/docker*" << std::endl;
    ss << "my_custom.slice/my_custom_cgroup" << std::endl;
    ss << "===" << std::endl;;
    
    return ss.str ();
}
